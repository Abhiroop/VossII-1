
\section{Symbolic Trajectory Evaluation and Verification}

There is currently only one built-in command for symbolic trajectory%
\index{symbolic trajectory evaluation}%
{}
evaluation called STE%
\index{STE}%
{}.
In general, STE determines, through symbolic trajectory evaluation, whether
an antecedent/consequent pair hold in for some circuit.
STE will return a datatype called ste which contains all the
result from the STE run.
This includes not only the result of the STE run, but also
trace data etc. collected during the simulation.

In general STE is invoked as
\begin{hol}
STE options ckt wl ant cons trl
\end{hol}
where options%
\index{STE options}%
{} is a string that can contain a combinations of the
following flags:
\begin{description}
\item[-a] Abort%
\index{abort STE}%
{} the verification at the first antecedent or consequent failure.
\item [-m n]
Abort the verification after n phases has been simulated.
\item [-e]
Evaluate evey node in the circuit whether the node is in the
fan-in tree of some node that is checked or traced or not.
In other words, with the -e option, the simulator will compute
the value on every node.
Normally, a node whose value cannot be observed (directly or indirectly)
is simply kept at X.
Of course, the STE command can run significantly slower with the
-e option, so beware!
\end{description}

The second argument to STE must be an object of the fsm type representing
a circuit that is to be simulated.

The weak\_list wl is a list of 4-tuples.
Each 4-tuple is of the form (g,n,f,t), where n is a node name, f and t
denote start and stop times, and g is a Boolean
denoting the domain for which this node should be weakened%
\index{weakened}%
{}.
For assignments making the guard true, the next state function of the
circuit node is set to $X$.
This is often useful when verifying a subsystem of a larger system
that has shared input signals.
By weakening%
\index{weakening}%
{} the model, unnecessary computations do not have to be performed.
Note that weakening a model is a ``safe'' operation in that
the monotonicity of the circuit models guarantee that if we
can verify something in the weakened model, then that same property
is guaranteed to hold in the original model.

The ant\_list and cons\_list are  both lists of five-tuples.
Each five-tuple%
\index{five-tuple}%
{} is of the form $(g,n,v,s,t)$, where $g$ is a Boolean function
denoting the domain for which this assertion/check should be carried out,
$n$ is the name of a node, $v$ is the value to be asserted/checked, and
$s$ and $t$ denote the start and stop times for this assertion/check
respectively.

Finally, the last argument to STE is a list of triples.
Each triple is of the form $(n,s,t)$, where $n$ is a name of a node
to be traced%
\index{traced}%
{} and $s$ and $t$ are the start and stop times for this
trace respectively.

Of course, in practice, it would be quite tedious to have to
write all specifications in terms of lists of five-tuples.
Consequently, a small embedded domain specific language
has been defined.
These functions make it much easier to write specification.
However, it should be remembered that when the verification
is actually performed, all these higher level constructs gets translated
down to the two lists of five-tuples.

For more details on how to use the STE function to perform formal
verification, we refer the reader to Section~\ref{tutorial}.

To illustrate the use of STE on a simple example, consider the simple
Verilog circuit from the previous section.
In this example, we will simply use STE as a symbolic simulator.
%%%START_CODE%%%%
load "ste.fl";
let p = verilog2pexlif "-Iverilog_examples"         // Yosys flags
                       "mux4"                       // Top-level module
                        ["small.v", "small_lib.v"]  // Files to read & compile
                        []                          // Additional files needed
;
let ckt = pexlif2fsm p;
%%%END_CODE%%%%
If we now define a simple antecedent, as follows:
%%%START_CODE%%%%
let ant =
    "din_0" is  "a" for 5 phases
  and
    "din_1" is	"b" for 5 phases
  and
    "din_2" is	"c" for 5 phases
  and
    "din_3" is	"d" for 5 phases
  and
    "sel[1:0]" is   "0x0" for 1 phase followed_by
		    "0x1" for 1 phase followed_by
		    "0x2" for 1 phase followed_by
		    "0x3" for 1 phase followed_by
		    "s[1:0]" for 1 phase
;
%%%END_CODE%%%%
we can run STE
%%%START_CODE%%%%
let ste_res = STE "-e" ckt [] ant [] [];
ste_res;
%%%END_CODE%%%%
and potentially see the output values on mux\_out:
%%%START_CODE%%%%
get_trace ste_res "mux_out";

rev it;
%%%END_CODE%%%%
Note that get\_trace returns a list of triples: $(t,H,L)$, where
$t$ is the phase the node took on this value and $H$ and $L$ are the
high and low rail values of the node. 
The encoding used is $(T,T)$ is X (unknown/should't matter),
$(T,F)$ is one, $(F,T)$ is zero, and
$(F,F)$ is top, or overconstrained.

