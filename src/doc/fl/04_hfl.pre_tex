
\section{Hardware Models}

An important part of the {\voss} system is its symbolic trajectory evaluation
(STE) formal verification engine.
Intuitively, STE is a generalization of a symbolic simulator in which the
Boolean domain has been extended to a lattice structure and thus
combines symbolic varaibles/expressions and lattice operations.
For the STE system to work, a model of some hardware is needed.
Currently, {\voss} provides two ways of getting such a model: 1) by reading in
a Verilog description using, a slightly extended, Yosys~\cite{yosys} system
or define the model directly in an extension of fl, called HFL.
Either way, an fl datatype called pexlif will be created first.
This datatype captures hiearchy, wire names, and RTL level assignments
(both instantaneous as well as delayed) of the hardware.
For further use, the pexlif is often compiled to a more
efficient model, called fsm..
We will return to this later.


\subsection{Pexlif}

The pexlif datatype is meant to be used to represent hardware modelled at
a register transfer level.
In other words, a pexlif model captures the design hierarchy (including
the wire names) as well as the zero-delay combinational parts and the
phase delay parts.
More specifically, the pexlif (and associated types) are defined as:
\begin{hol}
lettype pexlif =
        PINST 
            \{name::string\} 
            \{attrs::(string#string) list\}
            \{leaf::bool\}
            \{fa_inps:: (string#(string list)) list\}
            \{fa_outs:: (string#(string list)) list\}
            \{internals:: string list\}
            \{content::content\}
andlettype content = 
            P_HIER \{children::pexlif list\}
        |   P_LEAF \{fns::update_fn list\}
;
\end{hol}
and
\begin{hol}
lettype update_fn =
            W_UPDATE_FN \{lhs::wexpr\} \{rhs::wexpr\}
        |   W_PHASE_DELAY \{lhs::wexpr\} \{rhs::wexpr\}
;
\end{hol}
The word-level expressions (wexpr)%
\index{wexpr}
are defined as:
\begin{hol}
lettype wexpr =
            W_X \{sz::int\}
        |   W_CONST \{sz::int\} \{v::int\}
        |   W_NAMED_CONST \{name::string\} \{sz::int\} \{v::int\}
        |   W_VAR \{sz::int\} \{base::string\}
        |   W_EXPLICIT_VAR \{sz::int\} \{name::string\}
        |   W_AND \{a::wexpr\} \{b::wexpr\}
        |   W_OR \{a::wexpr\} \{b::wexpr\}
        |   W_NOT \{a::wexpr\} 
        |   W_EQ \{a::wexpr\} \{b::wexpr\}
        |   W_PRED \{name::string\} \{cond::wexpr\}
        |   W_GR \{a::wexpr\} \{b::wexpr\}
        |   W_ADD \{a::wexpr\} \{b::wexpr\}
        |   W_SUB \{a::wexpr\} \{b::wexpr\}
        |   W_MUL \{a::wexpr\} \{b::wexpr\}
        |   W_DIV \{a::wexpr\} \{b::wexpr\}
        |   W_MOD \{a::wexpr\} \{b::wexpr\}
        |   W_SHL \{a::wexpr\} \{b::wexpr\}
        |   W_SHR \{a::wexpr\} \{b::wexpr\}
        |   W_ASHR \{a::wexpr\} \{b::wexpr\}
        |   W_SX  \{sz::int\}  \{w::wexpr\}
        |   W_ZX  \{sz::int\}  \{w::wexpr\}
        |   W_ITE \{cond::wexpr\} \{t::wexpr\} \{e::wexpr\}
        |   W_SLICE \{indices::int list\} \{w::wexpr\}
        |   W_NAMED_SLICE \{name::string\} \{indices::int list\} \{w::wexpr\}
        |   W_CAT \{parts::wexpr list\}
        |   W_MEM_READ \{info::mem\} \{mem::wexpr\} \{addr::wexpr\}
        |   W_MEM_WRITE \{info::mem\} \{mem::wexpr\} \{addr::wexpr\} \{data::wexpr\}
;
\end{hol}
where
\begin{hol}
lettype mem = MEM
                \{addr_size::int\}
                \{lines::int\}
                \{data_size::int\}
;
\end{hol}
and is used to represent the various expressions in an RTL model.


To illustrate a simple function operating over a pexlif, here is one
computing the number of (internal) wires in a model:
%%%START_CODE%%%%
let get_children (P_HIER ch) = ch
 /\ get_children (P_LEAF _) = []
;

letrec number_of_wires (PINST name opts leaf fa_inps fa_outs ints content) =
    let local = length (md_expand_vectors ints) in
    leaf => local |
    itlist (\pp. \r. number_of_wires pp+r) (get_children content) local
;
%%%END_CODE%%%%
A more interesting function might be one that extracts a sub circuit
based on its name:
%%%START_CODE%%%%
letrec extract_subckts target p =
    val (PINST name opts leaf fa_inps fa_outs ints content) = p in
    str_is_suffix target name => [p] |
    leaf => [] |
    flatmap (extract_subckts target) (get_children content)
;
%%%END_CODE%%%%
Here we used only the sufix of the name to match.

\subsection{HFL}

In order to model hardware efficiently and with type safety, a deeply
embedded hardware description language, called HFL, has been created.
Since it is deeply embedded in fl, one can use many/most of fl's mechanisms
for describing the hardware. 
For example, it is quite easy to define a hardware structure recursively.

There are two parts to HFL: 1) a set of functions to create hardware types,
and 2) functions (many with special binder fixity) for describing the hardware.

\subsubsection{HFL Types}

A hardware type is effectively a algebraic datatype in fl for which a number
of destructor, constructor, and misc. other functions have been created.
There are four basic ways of creating a hardware type:
TYPE\index{TYPE}, ENUM\index{ENUM}, STRUCT\index{STRUCT}, and
MEMORY\index{MEMORY}.
The ENUM and STRUCT have two versions depending on how much control is needed
to define the encoding.
More precisely:
\begin{hol}
TYPE typename size

ENUM typename [name]
ENUM typename [(name,encoding)]

STRUCT typename [(fieldname,type)]
STRUCT typename [(fieldname,type,indices)]

MEMORY typename [size] wordtype
\end{hol}

To illustrate how to declare such types and how to extract/update
fileds, consider the following simple example:
%%%START_CODE%%%%
load "ste.fl";	// Must be loaded for HFL

TYPE "byte" 8;
TYPE "addr" 8;
TYPE "pc" 29;
{'a::byte};
{'a::addr};
{'a::pc};
%%%END_CODE%%%%
Here we declared three simple hardware types for vectors of size 4 and 8
respectively.
Note that although both byte and addr are of size 8, they are different types
and thus
%%%START_CODE%%%%
{'1::byte} '+' {'1::byte};  // Ok
{'1::byte} '+' {'1::addr};  // Fails typechecking
%%%END_CODE%%%%

To continue the example with the two types of ENUM:
%%%START_CODE%%%%
ENUM "op" ["ADD", "JMP", "NOP"];
ENUM "state" [("INIT", 1), ("FETCH", 2), ("EXECUTE", 4), ("WB", 8)];
{'a::op};
{'a::state};
ADD;
NOP;
INIT;
WB;
%%%END_CODE%%%%
where the second type gives an explicit encoding.
Note that it is valid to give the same encoding to two different
constants (although definitely not recommended!).
Note also that evaluating this command will create (zero-arity) functions
for the enumerated constants.
Note that these functions are overloaded (if needed) so that two differnt
ENUMs can have the same named constants.
It is up to the typechecking to resolve the usage so that the correct
encoding is used.
Sometimes, this will require a typecast.

Since enumerated types do not have any numerical value, it is
an error to try to perform aritmetic operations on them.
For example:
%%%START_CODE%%%%
ADD '+' JMP;
%%%END_CODE%%%%
fails.
(Note that since fl does not have dependent types, the failure is a
runtime failure triggered when the pexlif is built.)

The STRUCT function creates a bitvector as well as accessor functions for
the different fields.
The first version of STRUCT is simply useful when creating ``bundles'' of
other vectors.
For example:
%%%START_CODE%%%%
STRUCT "bundle" [("high","byte"),("low","byte")];
'a-->high;			    // Extract field
'a<--high ? '0xab;		    // Update field
'a<--high ? '0xab <-- low ? '0xba;  // Nested updates
%%%END_CODE%%%%
The more general STRUCT function allows the fields to overlap.
Since the system cannot easily determine the size of the resulting
type, the user has to give the size.
Also, each field now consists of three items: the name of the field,
the type of the field, and a list of indices in the vector that this
field refers to.
For example:
%%%START_CODE%%%%
STRUCT "opcode" 32 [
                    ("opcode", "op", [31,29]),  // Non-contigous!
                    ("dest", "addr", (23--16)),
                    ("src1", "addr", (15--8)),
                    ("src2", "addr", (7--0)),
                    ("target", "pc", (28--0))
                    ]
;

'a-->opcode;
'a-->dest;
'a-->target;

'0<--opcode ? ADD
  <--dest   ? '0x1
  <--src1   ? '0x2
  <--src2   ? '0x3
;

'0<--opcode ? JMP
  <--target ? '0xabba
;
%%%END_CODE%%%%

Finally, the MEMORY construct is used to create, possibly multi-dimensional,
arrays.
When a MEMORY type ``foo'' is created, there are four additional functions
created:
\begin{hol}
read_foo  {mem:: foo} addr_1 addr_2 ... addr_n
write_foo {mem:: foo} addr_1 addr_2 ... addr_n new_data
Read_foo  {mem:: foo} addr_1 addr_2 ... addr_n out_name
Write_foo {mem:: foo} addr_1 addr_2 ... addr_n new_data new_mem
\end{hol}
The read\_foo takes a memory and a list of addresses (one for each dimension
of the memory) and returns the value in that memory location.
The write\_foo takes a memory and a list of addresses and a new data value
and returns the new memory in which the data at the selected address has been 
replaced with the new_data.
The Read\_foo and Write\_foo functions are functions that create a pexlif
for the corresponding operation (and thus has a better visualization).
We will return to these later.

A simple example of MEMORY could be:
%%%START_CODE%%%%
MEMORY "regfile" [(10,"addr")] "byte";
{'a::regfile};
read_regfile 'a '0x3;
write_regfile 'a '0x0 '0xab;
write_regfile 'a '0x3 'd;
%%%END_CODE%%%%

A more complex example:
%%%START_CODE%%%%
MEMORY "array" [(4,"addr"),(5,"addr")] "byte";
{'a::array};
read_array 'a '0x3 '0x1;
write_array 'a '0x0 '0x0 '0xab;
write_array 'a '0x3 '0x2 'd;
%%%END_CODE%%%%

\subsubsection{HFL Expressions}

To make it more convenient 

\subsubsection{HFL Circuit Descriptions}



\subsection{Verilog models}

{\voss} uses the Yosys system to provide a fairly complete Verilog 2005
parser, type checker, elaborator, and lightweight synthesis path.
As a result, there is an fl function, called verilog2pexlif%
\index{verilog2pexlif}
that reads in Verilog file(s) and converts the model into a pexlif.
In order to use it though, a standard library called "ste.fl" must first
be loaded.

For example, if there are two files small.v and small\_lib.v in the
directory verilog\_examples, that look like:
\begin{hol}
// File: small_lib.v
module  mux2(
    din_0      , // Mux first input
    din_1      , // Mux Second input
    sel        , // Select input
    mux_out      // Mux output
);
//-----------Input Ports---------------
input din_0, din_1, sel ;
//-----------Output Ports---------------
output mux_out;
//------------Internal Variables--------
reg  mux_out;
//-------------Code Starts Here---------
always @*
begin : MUX
 case(sel ) 
    1'b0 : mux_out = din_0;
    1'b1 : mux_out = din_1;
 endcase 
end
endmodule
\end{hol}
and
\begin{hol}
// File: small.v
module  mux4(
    din_0      , // Mux first input
    din_1      , // Mux Second input
    din_2      , // Mux Thirsd input
    din_3      , // Mux Fourth input
    sel        , // Select input
    mux_out      // Mux output
);
//-----------Input Ports---------------
input din_0, din_1, din_2, din_3 ;
input [1:0] sel ;
//-----------Output Ports---------------
output mux_out;
//------------Internal Variables--------
reg  mux_out;
reg  mid01, mid23;
//-------------Code Starts Here---------
    mux2 mux1  (.din_0(din_0), .din_1(din_1), .sel(sel[0]), .mux_out(mid01));
    mux2 mux2  (.din_0(din_2), .din_1(din_3), .sel(sel[0]), .mux_out(mid23));
    mux2 mux12 (.din_0(mid01), .din_1(mid23), .sel(sel[1]), .mux_out(mux_out));

endmodule
\end{hol}
We could now do:
%%%START_CODE%%%%
load "ste.fl";
let p = verilog2pexlif "-Iverilog_examples"	    // Yosys flags
                       "mux4"			    // Top-level module
                        ["small.v", "small_lib.v"]  // Files to read & compile
                        []			    // Additional files needed
;
%%%END_CODE%%%%
followed by:
%%%START_CODE%%%%
number_of_wires p;
%%%END_CODE%%%%
or
%%%START_CODE%%%%
extract_subckts "not" p;
%%%END_CODE%%%%

\subsection{fsm}

Although the pexlif format is convenient for representing a circuit, it is
not very efficient for simulation.
Thus, an internal datatype, called fsm, is used.
A pexlif can be converted to an fsm by simply calling pexlif2fsm.
%%%START_CODE%%%%
let ckt = pexlif2fsm p;
ckt;
%%%END_CODE%%%%

There a number of functions that operate on the fsm datatype.
For example:
%%%START_CODE%%%%
// Get a list of all inputs to the circuit
inputs ckt;

// Get a list of all outputs of the circuit
outputs ckt;

// Return the immediate fanin from a node in a circuit.
fanin ckt "mux_out";

// Return the immediate fanout from a node in a circuit.
fanout ckt "mid01";

// Find the full vector given a node in it.
node2vector ckt "sel[0]";

// Use fanin_dfs to recursively go back until a toplevel node is encounterd
let top_fanin ckt nd =
    let toplevel n = NOT (str_is_substr "/" n) in
    let all_inps = fanin_dfs ckt toplevel [nd] in
    let top_level_inps = filter toplevel all_inps in
    top_level_inps subtract [nd]
;

top_fanin ckt "mux_out";
%%%END_CODE%%%%

As usual, use the help system to find all functions that can be applied to
an fsm.

% \subsection{Circuit Models}
% 
% Since the main use of the fl system, and its historical root, is related
% to hardware verification, there are a number of built-in
% functions specifically tailored towards hardware modeling
% and symbolic trajectory evaluation in particular. 
% Internally, a circuit is represented by a list of nodes (names),
% and a next state function%
% \index{next state function}%
% {}.
% The next state function is mapping the current state of the circuit
% (including the current values on the inputs) to a new state
% of the circuit.
% Since the circuit representation is intended for trajectory evaluation,
% the value domain for each node in the circuit is $\{0,1,\X,\top\}$
% and thus the next state function consists of quaternary%
% \index{quaternary}%
% {} (four-valued)
% extensions of the usual Boolean function.
% The type of such circuit is fsm%
% \index{fsm}%
% {} (for finite state machine%
% \index{finite state machine}%
% {}) and, by
% default, it does not have a print function (since the machines
% are usually much too large to be meaningful anyway to the user.
% However, for the curious reader, the command print\_fsm%
% \index{print\_fsm}%
% {} will print out
% a pretty complete version of the state machine.
% Note that for efficiency reasons, the next state function also
% contains delay and fan-in and fan-out information to aid in the
% efficient simulation.
% 
% In general, there are two ways of creating a fsm object:
% \begin{enumerate}
% \item
% Loading a pre-compiled version of a circuit in .exe format.
% \item
% Converting a fl structure into an fsm.
% \end{enumerate}
% 
% \subsubsection{Loading a .exe File}
% 
% If the original circuit was described in Berkeley .sim format or
% as a SILOS II gate list, there are programs distributed with the
% system that can be used to compile an fsm model directly from
% these formats.
% The common format for such pre-compiled circuit model is a (binary)
% file with a .exe%
% \index{.exe file}%
% {} suffix.
% %In Section~\ref{CompanionTools} we discuss in more detail how
% %to create such .exe file.
% Loading in the .exe file and making it an fsm object simply
% involves calling the load\_exe function.
% 
% For example, if there is a full\_adder.exe file in the current
% working directory, the following command would create an fsm object
% of the circuit.
% %%%START_CODE%%%%
% let ckt1 = load_exe "full_adder.exe";
% %%%END_CODE%%%%
% Note that there is no theoretical limit on the number of circuit that can
% be loaded into the fl system at any particular point in time.
% However, since fsm models are often quite large, it is generally
% advisable not to load more models than absolutely necessary.
% %(In most cases, only one model will be used, but there are times
% %when several models can be useful. We will return to this later
% %in Section~\ref{ModelChecking}.)
% 
% \subsubsection{Creating an fsm Object Inside fl}
% \label{makeSTEsection}
% 
% {\bf Warning:} This addition is fairly young and has thus not
% been extensively tested. Also, it leaves quite a bit to
% be desired in terms of not being very ``clean and simple''.
% For a reader that is more interested in using the {\voss} system rather
% than writing a new conversion program from some other netlist format, this
% section can be skipped.
% 
% The main routine for creating an fsm object is make\_fsm%
% \index{make\_fsm}%
% {}.
% The type of make\_fsm is (Set)\funarrow (fsm)\footnote{Currently, when
% fl is invoked, the type of make\_fsm is actually (*)\funarrow (fsm), but
% this is a bug that will be removed in the next release.}
% Before going into how an object of type Set%
% \index{Set}%
% {} can be constructed, we
% need to make a small digression and introduce the quaternary logic type.
% For historical reasons, the name of the quaternary objects is tern%
% \index{tern}%
% {},
% and tern is defined as the concrete type:
% %%%START_CODE%%%%
% lettype tern =  One |
%                 Zero |
%                 X |
%                 Z |
%                 Val string |
%                 And tern tern |
%                 Or tern tern |
%                 Not tern |
%                 Glb tern tern |
%                 Lub tern tern
% ;
% %%%END_CODE%%%%
% where One%
% \index{One}%
% {}, Zero%
% \index{Zero}%
% {}, X%
% \index{X}%
% {},  And%
% \index{And}%
% {}, Or%
% \index{Or}%
% {}, and Not%
% \index{Not}%
% {} are the obvious functions.
% Glb%
% \index{Glb}%
% {} stands for the greatest lower bound and Lub%
% \index{Lub}%
% {} for the least upper bound.
% Z%
% \index{Z}%
% {} is used to represent the top value%
% \index{top value}%
% {}.
% Finally, Val%
% \index{Val}%
% {} s is used to refer to the value on node s.
% Thus, as a concrete example, the next state function of a node "o" may
% be described as (Not (And (Val "in1") (Val "in2"))).
% 
% There are four constructor functions for an object of type Set:
% \begin{enumerate}
% \item
% Empty%
% \index{Empty}%
% {},
% \item
% Element%
% \index{Element}%
% {} (string\verb@#@((tern\verb@#@tern) list)),
% \item
% Union%
% \index{Union}%
% {} Set Set, and
% \item
% Sequential%
% \index{Sequential}%
% {} Set Set.
% \end{enumerate}
% The Empty is introduced to make writing functions that generate
% objects of type Set easier.
% Element is the constructor that actually introduces new nodes and
% also give driver functions for the node.
% In general, Element n gvl, will create a node named n.
% This node will at least have (more about this later) the drivers
% listed in the gvl list.
% A driver is simply a pair of quaternary expressions:
% the first object of the pair is a guard, and the second part
% is the value being driven when the guard is true.
% For a combinational node, the driver list is a single pair whose
% guard is One and whose value component is the next state function
% of the gate.
% For more complex nodes, like register nodes or bus nodes, the guard-value
% list is often much longer.
% 
% The Union construct is used to gather a collection of these Element
% declarations so that an fsm can eventually be made.
% Finally, the Sequential constructor takes two objects S1 and S2 of
% type Set and merges them into a single object of type Set.
% In that sense, Sequential behaves exactly like Union.
% The difference is how the two deal with nodes defined in both set S1 and set S2
% and for which both nodes may have at least one of their guards enabled
% at the same time.
% Union will find the greatest lower bound of the values being driven
% at the same time whereas Sequential will assume that the driver in the
% second set overrides the driver in the first.
% To illustrate the difference, consider the following example:
% %%%START_CODE%%%%
% let a = Element ("in1", [(One, One)]);
% let b = Element ("in1", [(One, Zero)]);
% let ex1 = Union a b;
% let ex2 = Sequential a b;
% let m1 = make\_fsm ex1;
% let m2 = make\_fsm ex2;
% m1;
% %%%END_CODE%%%%
% Now m1 and m2 will both be fsm models with a single node called in1.
% However, in m1, the next state function of in1 will be $\X$, since that
% is the most we can say from the inconsistent driver commands given
% in the example.
% On the other hand, the next state function of the in1 node in m2 will be Zero.
% 
% For an example of using this facility, the directory HDL in the demo
% distribution illustrates how one can go about defining a new description
% language in order to create an fsm object.
% 
% \subsection{Queries to the Circuit Model}
% 
% There are five built-in functions that are useful in dealing with
% an fsm model: nodes%
% \index{nodes}%
% {}, fanin%
% \index{fanin}%
% {}, fanout%
% \index{fanout}%
% {}, is\_stable%
% \index{is\_stable}%
% {}, and get\_node\_val%
% \index{get\_node\_val}%
% {}.
% Nodes takes an fsm model and returns a {\em list of lists} of circuit nodes.
% The reason for the double listing is that a node may have more than
% one name (only from .exe file translations).
% Fanin takes an fsm model and a name of a node and returns the
% list of node names that the next state function depend on.
% Fanout works in a similar way, but for the fanout nodes.
% Is\_stable returns T (true) if the circuit is currently stable.
% It is mainly used when the simulation is aborted at some
% particular time with the "-m" option to STE.
% Finally, get\_node\_val takes an fsm object and the name of a node
% and returns the encoded version of the current value of the node.
% The encoding used is: $\X = (T,T)$, $1=(T,F)$, $0=(F,T)$, and $\top=(F,F)$.
% Of course, the two Boolean values are often Boolean functions over some
% variables.
% The main use of the get\_node\_val function is when the simulation
% is aborted for some reason.
% Get\_node\_val can then be used to probe the current state of the system.
% For example, assuming there is a full\_adder.exe file in the current
% working directory, we would get:
% %%%START_CODE%%%%
% let ckt = load_exe "full_adder.exe";
% nodes ckt;
% ..[["cout"],["t4"],["t3"],["t2"],["result"],["cin"],["t1"],["b"],["a"]]
% fanin ckt "cout";
% fanout ckt "t3";
% fanout ckt "t4";
% fanout ckt "a";
% get_node_val ckt "t2";
% %%%END_CODE%%%%
% 
% If the user also loads in the "default.fl" standard library, there is
% the very useful function {\em excitation}%
% \index{excitation}
% that also takes an fsm model
% and a node name, but that returns the next state function for binary inputs.
% Note, however, that the current version of the excitation function
% only works correctly for unit delay nodes.
% %%%START_CODE%%%%
% load "defaults.fl";
% excitation ckt "cout";
% %%%END_CODE%%%%
% We will return to this in Section~\ref{vossrc}.
% 
% \subsection{Symbolic Trajectory Evaluation}
% 
% There is actually only one built-in command for symbolic trajectory%
% \index{symbolic trajectory evaluation}%
% {}
% evaluation called STE%
% \index{STE}%
% {}.
% In general, STE determines, through symbolic trajectory evaluation, whether
% an antecedent/consequent pair hold in for some circuit.
% STE will return a Boolean function that gives the condition for the
% verification to succeed.
% For most applications the desired return value is T.
% 
% In general STE is invoked as
% %%%START_CODE%%%%
% STE options fsm weak_list ant_list cons_list trace_list
% %%%END_CODE%%%%
% where options%
% \index{STE options}%
% {} is a string that can contain a combinations of the
% following flags:
% \begin{description}
% \item[-a] Abort%
% \index{abort STE}%
% {} the verification at the first antecedent or consequent failure.
% If the verification is aborted, STE will return a Boolean function that
% gives {\em the condition for this failure to manifest itself}.
% Note that this is contrary to STE's usual behavior which is to return
% the Boolean function that gives the conditions for the verification to
% succeed.
% \item [-m n]
% Abort the verification after reaching time n.
% \item [-e]
% Evaluate evey node in the circuit whether the node is in the
% fan-in tree of some node that is checked or traced or not.
% In other words, with the -e option, the simulator will compute
% the value on every node. Normally, a node whose value
% cannot be observed (directly or indirectly) is simply kept at X.
% Of course, the STE command can run significantly slower with the
% -e option, so beware!
% \item [-i]
% Allow antecedent failures%
% \index{antecedent failures}%
% {}.
% In other words, compute a straight implication.
% The normal behavior of the verification process is to disallow
% antecedent failures.
% Thus the default verification condition is both to check that every
% trajectory the circuit can go thorough that is consistent with the
% antecedent is also consistent with the consequent, and that there
% is at least one (real) circuit trajectory that is consistent
% with the antecedent.
% \item [-n]
% Allow over-constrained values, i.e., allow nodes to take
% on the top value in the value lattice.
% Normally, over-constrained values are viewed as failures.
% \item[-w]
% Do not print out warning messages%
% \index{warning messages}%
% {}.
% \item[-t s]
% In addition to printing out trace messages on stderr, also send
% the trace events in Postscript%
% \index{Postscript waveform}%
% {} format to the file s.
% By previewing or printing out the file the user gets a waveform diagram for
% the traced signals.
% \item[-T s]
% Same as -t, but generate Postscript code in landscape mode.
% \end{description}
% 
% The second argument to STE must be an object of the fsm type representing
% a circuit that is to be simulated.
% 
% The weak\_list is a list of 4-tuples.
% Each 4-tuple is of the form (g,n,f,t), where $n$ is a node name, $f$ and $t$
% denote start and stop times, and $g$ is a Boolean function
% denoting the domain for which this node should be weakened%
% \index{weakened}%
% {}.
% For assignments making the guard true, the next state function of the
% circuit node is set to $X$.
% This is often useful when verifying a subsystem of a larger system
% that has shared input signals.
% By weakening%
% \index{weakening}%
% {} the model, unnecessary computations does not have
% to be performed.
% Note that weakening a model is a ``safe'' operation in that
% the monotonicity of the circuit models guarantee that if we
% can verify something in the weakened model, then that same property
% is guaranteed to hold in the original model.
% 
% The ant\_list and cons\_list are  both lists of five-tuples.
% Each five-tuple%
% \index{five-tuple}%
% {} is of the form $(g,n,v,s,t)$, where $g$ is a Boolean function
% denoting the domain for which this assertion/check should be carried out,
% $n$ is the name of a node, $v$ is the value to be asserted/checked, and
% $s$ and $t$ denote the start and stop times for this assertion/check
% respectively.
% 
% Finally, the last argument to STE is a list of triples.
% Each triple is of the form $(n,s,t)$, where $n$ is a name of a node
% to be traced%
% \index{traced}%
% {} and $s$ and $t$ are the start and stop times for this
% trace respectively.
% 
% Of course, in practice, it would be quite tedious to have to
% write all specifications in terms of lists of five-tuples.
% Consequently, a small language (actually a small set of useful functions)
% has been defined in the library file "verification.fl".
% These functions make it much easier to write specification.
% However, it should be remembered that when the verification
% is actually performed, all these higher level constructs gets translated
% down to the two lists of five-tuples.
% 
% For more details on how to use the STE function, we refer the reader
% to Section~\ref{tutorial}.
